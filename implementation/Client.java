package merkle.implementation;

import merkle.Configuration;
import merkle.IClient;
import merkle.IMerkleTree;

import java.util.List;

/**
 * TASK 2
 * TODO: IMPLEMENT verifyResponse
 *
 * @euthuppa
 * @pso 17
 * @10/26/16
 */
public class Client extends IClient {

    /**
     * Given the path siblings this function has to verify if
     * the masterHash generated by concatenating and hashing
     * level by level is the same as <i>this.masterHash</i>
     * You can use <i>Configuration.hashFunction</i>
     */
    protected boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception {
        //TODO:implement
        boolean matched = false;
        /*
         * You need to use Configuration.hashFunction and this.masterHash to determine a match
         */
        int i = 2;  //Start at index 2
        String hashCheck;
        IMerkleTree.Node node;

        /*
        Gotta do the first 2 Nodes
         */
        if (pathSiblings.get(0).getType() == IMerkleTree.NodeType.left) {
            hashCheck = Configuration.hashFunction.concatenateHash(pathSiblings.get(0), pathSiblings.get(1));
            node = new IMerkleTree.Node(hashCheck, pathSiblings.get(0).getIndex() / 2);//Put this hash into a node
        }
        else {
            hashCheck = Configuration.hashFunction.concatenateHash(pathSiblings.get(1), pathSiblings.get(0));
            node = new IMerkleTree.Node(hashCheck, pathSiblings.get(0).getIndex() / 2);//Put this hash into a node
        }

        /*
        Do the rest if there's more
         */
        while (i < pathSiblings.size()) {
            if (pathSiblings.get(i).getType() == IMerkleTree.NodeType.left) {
                hashCheck = Configuration.hashFunction.concatenateHash(pathSiblings.get(i), node);
                node = new IMerkleTree.Node(hashCheck, pathSiblings.get(i).getIndex() / 2);
            }
            else{
                hashCheck = Configuration.hashFunction.concatenateHash(node, pathSiblings.get(i));
                node = new IMerkleTree.Node(hashCheck, pathSiblings.get(i).getIndex() / 2);
            }
            i++;
        }

        if (hashCheck.equals(this.masterHash)) {
            matched = true;
        }
        return matched;
    }
}
